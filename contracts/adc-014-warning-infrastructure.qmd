---
title: "ADC-014: Warning vs Error Infrastructure"
date: 2025-11-10
status: planned
priority: 3
---

## Contract Metadata

- **Contract ID**: spellcraft-adc-014
- **Title**: Warning vs Error Severity Infrastructure
- **Date Issued**: 2025-11-10
- **Status**: Planned
- **Depends On**: ADC-013 (Process Parsing), ADC-012 (Violation Detection)
- **Iteration**: 1

## Purpose

Establish a unified infrastructure for distinguishing between errors (critical violations) and warnings (non-critical issues) in the Spellcraft analyzer. This will allow more nuanced reporting where some issues block compilation while others are informational.

## Motivation

**Current State**:
- All violations reported as errors
- No distinction between critical and informational issues
- Unused signals should be warnings (once false positives are fixed)
- Users cannot filter by severity

**Desired State**:
- Clear error vs warning distinction
- Configurable severity levels
- Suppressible warnings
- Severity-based exit codes

## Scope

### In Scope

**Core Infrastructure**:
- Unified `Severity` type (Error, Warning, Info)
- Generic `Issue` type that can hold any violation with severity
- Severity configuration system
- Warning suppression mechanisms

**Severity Classifications**:
- **Errors** (block compilation):
  - Undriven signals (no source at all)
  - Frequency violations
  - Type mismatches

- **Warnings** (informational):
  - Unused signals (written but not read)
  - Potential latch inference
  - Missing default cases

- **Info** (suggestions):
  - Performance optimizations
  - Code style issues

### Out of Scope

- Linting rules
- Style guide enforcement
- Auto-fix suggestions

## Deliverables

### Core Types

**File**: `src/VHDL/Analysis/Issue.hs`

```haskell
data Severity = Error | Warning | Info
  deriving (Show, Eq, Ord)

data Issue = Issue
  { issueSeverity :: Severity
  , issueType :: IssueType
  , issueMessage :: Text
  , issueLocation :: SourceLocation
  , issueSuggestion :: Maybe Text
  }

data IssueType
  = SignalUsageIssue
  | FrequencyIssue
  | ControlFlowIssue
  | ArithmeticIssue
  | ClockDomainIssue
```

### Configuration

**File**: `src/VHDL/Config.hs`

```haskell
data WarningConfig = WarningConfig
  { wcTreatWarningsAsErrors :: Bool
  , wcSuppressedWarnings :: Set IssueType
  , wcMinSeverity :: Severity
  }
```

### Report Updates

- Separate error and warning counts
- Color coding (red for errors, yellow for warnings)
- Exit code 0 if only warnings (unless --warnings-as-errors)
- Summary shows both counts

## Validation Criteria

### Success Metrics

- ✅ Unused signals reported as warnings
- ✅ Undriven signals remain errors
- ✅ Exit code 0 with only warnings
- ✅ --warnings-as-errors flag works
- ✅ Warnings can be suppressed

### Test Cases

1. File with only warnings → exit 0
2. File with errors → exit 1
3. --warnings-as-errors → warnings cause exit 1
4. --suppress-warnings → warnings hidden

## Prerequisites

**Must Complete First**:
1. ADC-013 (Process Parsing) - to eliminate false positives
2. Validate real vs false violations

**Rationale**: No point in warning infrastructure if 100% of warnings are false positives.

## Implementation Plan

### Phase 1: Core Types (Week 1)
- Define Severity and Issue types
- Create conversion functions
- Update existing violation types

### Phase 2: Integration (Week 2)
- Update Report module
- Add CLI flags
- Color coding

### Phase 3: Configuration (Week 3)
- Warning suppression
- Config file support
- Per-file pragmas

## Success Criteria

- Clear distinction between errors and warnings
- Configurable severity handling
- No breaking changes to existing CLI
- Performance impact < 5%

---

**Contract Status**: Planned (blocked by ADC-013)
**Prerequisites**: Complete process parsing first
**Next Review**: After ADC-013 completion